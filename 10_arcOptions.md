# Архитектурные опции
## Сервер
### Стиль построения приложений
Микросервисы.
Вопрос монолита даже не стоит, ибо размеры приложения даже на этапе планирования зашкаливают, очень уж сложно будет его разрабатывать и поддерживать. 
#### Плюсы
1. Один из критериев - расширяемость. Добавить новый сервис - в разы легче, чем дописывать монолит.
2. Очень разноплановый функционал с очень разными методами. В одной голове код просто не поместится. 
3. Легкость в дальнейшей разработке и поддержке имеющихся функций
4. Разделения сфер ответственности повышает безопасность
5. Смерть 1 сервиса, за редким исключением, не приведет к потере работоспособности системы в целом.
6. Возможность гибкой настройки системы с использованием синхронных и асинхронных взаимодействий.
7. По определению высокая производительность.

#### Минусы
1. Сложность развертывания. Проблема решена наличием широкого набора специалистов и опыта у них (согласно условиям задачи)
2. Дорогая инфраструктура. (Решена наличием наших серверных мощностей)
3. Много потенциальных точек отказа. Кроме самих сервисов - еще и передача данных между ними, балансировщики, очереди событий и т. д. (Нужно заранее продумать безопасноть и надежность этих узолов)

### Оборудование
У нас уже есть имеющиеся серверные мощности и на начальном этапе внедрения приложения использовать именно их - оптимальный выход:
1. Не требует дополнительных финансовых затрат
2. Уже есть доступ и обслуживание
3. Всегда можно переехать на отдельное железо, если на то будет рыночная необходимость и выгода.

#### Возможные проблемы:
1. При внезапном наплыве посетителей можем повесить не только нес, но и "соседей". Нужно жестко определять выделяемые ресурсы.
2. Умереть может и сосед, повесив нас. Но там тоже свои, мы им верим.
3. Рост посещаемости может оказаться настолько стремительным, что придется переезжать в авральном режиме. Но это надо смотреть по полученной статисткие. Скорее всего, рост будет очень плавным и невысоким. 

### Базы данных
Основным критерием БД для нас является надежность. У нас нет необходимости в сверхбыстрой обработке огромных массивов информации, ровно как и критериев качества, завязанных именно на запросах к БД. 
Более надежной счтается SQL, NoSQL хороши именнно в скорость. Так же SQL легче обрабатывать с точки зрения согласованности данных.

У нас масса специалистов, среди них наверняка найдется мастер PostgreSQL. Она почти как MySQL, только лучше.
1. По мнение многих, очень стабильная СУБД, ее практически невозможно уронить, порушить таблицы как в MySQL.
2. Хорошо структурированные данные, но с некоторой гибкости в схеме данных (JSON/BJSON);
3. При помощи сторонних библиотек просто и удобно расширяться в кластеры и делать шардинг таблиц.

Из сложностей:
1. Надо уметь готовить и настраивать. Сложно настроить это всё качественно. Но у нас уже есть спецы.

### Подход к разработке
У нас уже очень много готовых элементов, программистов, решений. НАВЕРНЯКА часть модулей, таких как api, логирование, авторизация уже написаны и испытаны. 
Всё, что есть готового - взять и переиспользовать. Затем уже смотреть, чего не хватает и анализировать. Возможно, купить, возможно - писать своё.

## Приложение
### Стиль построения приложений
Мы ограничены особенностью работы приложений на мобильных устройствах, потому в любом случае нужно монолитное решение.
В качествен основы возьмем жесткое доменное разделение внутри монолита по области применения, что позволит оптимизировать работку с кодом и упростит его сборку и обработку при параллельной работе нескольких команд.

### Использование инфраструктуры и БД
Приложение локально, не содержит в себе требований по быстродействию.
Использовать следует "внутренние" в рамках приложения БД, например sqlLite, что поможет и обеспечить безопасность (никто не залезет вовнутрь без разрешения), так и не будет черезчуур дорогим. 
Так же такая БД позволит приложению быть автономным. 
SQL подход позволит удобно обмениваться с сервром данными и бекапами.

### Подход к разработке
Самым очевидным является использование кроссплатформенного подхода. 
1. Приложение выходит сразу для iOS и Android.
2. На написание кода сразу для двух платформ требуется меньше времени.
3. Не нужно думать, как запрограммировать стандартные элементы интерфейса — с этим справится фреймворк.
4. При обновлении новую версию получают сразу обе платформы.
5. Пользователи получают одинаковый интерфейс и логику работы.

Минусы:
1. В некоторых местах всё-таки требуется писать нативный код, разный для каждой платформы, потому что фреймворки умеют не всё.
2. У программиста должна быть высокая квалификация — он должен знать особенности разработки для iOS и Android. Наш штат любит новенькие задачи, даже если они ранее и решались.
3. Когда приложение становится слишком большим и обрастает новыми возможностями, его становится сложно поддерживать. Увы, монолит такой монолит...

---
<p align="right"><a href="11_ADR.md">[Далее]</p>